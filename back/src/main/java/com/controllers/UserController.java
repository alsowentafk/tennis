package com.controllers;import com.google.gson.Gson;import com.models.ConfirmationToken;import com.models.LoginDataDTO;import com.models.User.User;import com.models.User.UserDTO;import com.properties.FileStorageProperties;import com.responses.UserVerificationResponse;import com.services.ConfirmationTokenService;import com.services.FileStorageService;import com.services.UserService;import com.transoformers.UserUserDTO;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.core.io.Resource;import org.springframework.http.HttpHeaders;import org.springframework.http.MediaType;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.*;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpServletRequest;import java.awt.*;import java.io.IOException;import java.net.URI;import java.net.URISyntaxException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.Calendar;import java.util.List;@Slf4j@CrossOrigin@RestController@RequiredArgsConstructor@RequestMapping("/api/user")public class UserController {    private final FileStorageService fileStorageService;    private final UserService userService;    private final FileStorageProperties fileStorageProperties;    private final ConfirmationTokenService confirmationTokenService;    private final UserUserDTO converter;    @PostMapping    public UserVerificationResponse save(@RequestBody UserDTO userDTO) {//        UserVerificationResponse userVerificationResponse = new UserVerificationResponse();//        UserDTO existingUserEmail = userService.findUserByEmail(userDTO.getEmail());//        if (existingUserEmail != null && existingUserLogin != null) {//            userVerificationResponse.setStatus(500);//            userVerificationResponse.setMessage("User with this login and email already exist");//            userVerificationResponse.setLogin(existingUserLogin.getLogin());//            userVerificationResponse.setEmail(existingUserLogin.getEmail());//            userVerificationResponse.setUser_id(existingUserLogin.getUser_id());//        } else if (existingUserEmail != null) {//            userVerificationResponse.setStatus(500);//            userVerificationResponse.setMessage("User with this email already exist");//            userVerificationResponse.setEmail(existingUserEmail.getEmail());//            userVerificationResponse.setLogin(existingUserEmail.getLogin());//            userVerificationResponse.setUser_id(existingUserEmail.getUser_id());//        } else if (existingUserLogin != null) {//            userVerificationResponse.setStatus(500);//            userVerificationResponse.setMessage("User with this login already exist");//            userVerificationResponse.setEmail(existingUserLogin.getEmail());//            userVerificationResponse.setLogin(existingUserLogin.getLogin());//            userVerificationResponse.setUser_id(existingUserLogin.getUser_id());//        } else {//            User user = converter.ConvertToUser(userDTO);//            userService.save(converter.ConvertToUserDTO(user));//            log.info("save {} at {}", userDTO.getLogin(), Calendar.getInstance().getTime());//            userVerificationResponse.setStatus(200);//            userVerificationResponse.setMessage("Successful registration");//            userVerificationResponse.setEmail(userDTO.getEmail());//            userVerificationResponse.setLogin(userDTO.getLogin());//            userVerificationResponse.setUser_id(userDTO.getUser_id());//        }//        return userVerificationResponse;        return null;    }    @GetMapping("/hello")    private String hello(){        return "Hello fucking spring docker network";    }    @GetMapping("/getUserById")    public UserDTO getUserByID(@RequestParam String id) {        log.info("get {} at {}", userService.getUserByID(Long.valueOf(id)), Calendar.getInstance().getTime());        return userService.getUserByID(Long.valueOf(id));    }    @PutMapping(consumes = {"multipart/mixed", "multipart/form-data"}, value = "/updateUserWithPhoto")    public void updateUserWithPhoto(@RequestParam("object") String userJSON,                                    @RequestParam("file") MultipartFile file) {        Gson gson = new Gson();        UserDTO userDTO = gson.fromJson(userJSON, UserDTO.class);        String fileName = fileStorageService.storeFile(file);        userDTO.setImage(fileName);        userService.update(userDTO);        log.info("save {} at {}", userDTO, Calendar.getInstance().getTime());    }    @PutMapping("/updateUserWithOutPhoto")    public void updateUserWithPhoto(@RequestBody UserDTO userDTO) {        userService.update(userDTO);        log.info("save {} at {}", userDTO, Calendar.getInstance().getTime());    }    @GetMapping("/all")    public List<UserDTO> getAllUsers() {        log.info("get all Users at {}", Calendar.getInstance().getTime());        return userService.getAllUsers();    }    @DeleteMapping("{id}")    public void delete(@PathVariable Long id) throws IOException {        log.info("delete {} at {}", userService.getUserByID(id), Calendar.getInstance().getTime());        userService.delete(id);        Files.delete(Paths.get(fileStorageProperties.getUploadDir() + userService.getUserByID(id).getImage()));    }    @GetMapping("/downloadFile/{id}")    public ResponseEntity<Resource> downloadFile(@PathVariable Long id, HttpServletRequest request) {        String fileName = userService.getUserByID(id).getImage();        Resource resource = fileStorageService.loadFileAsResourse(fileName);        String contentType;        try {            contentType = request.getServletContext().getMimeType(resource.getFile().getAbsolutePath());        } catch (IOException ex) {            log.info("Could not determine file type." + fileName + ex);            throw new RuntimeException(ex.getMessage());        }        if (contentType == null) {            contentType = "application/octet-stream";        }        log.info("File downloaded successful" + fileName);        return ResponseEntity.ok().contentType(MediaType.parseMediaType(contentType))                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + resource.getFilename() + "\"")                .body(resource);    }    @RequestMapping(value = "/confirm-account", method = {RequestMethod.GET, RequestMethod.POST})    public void confirmUserAccount(@RequestParam("token") String confirmationToken) throws URISyntaxException, IOException {        UserVerificationResponse userVerificationResponse = new UserVerificationResponse();        ConfirmationToken token = confirmationTokenService.findByConfirmationToken(confirmationToken);        if (token != null) {            UserDTO userDTO = userService.findUserByEmail(token.getUser_id().getEmail());            userDTO.setIs_confirmed(true);            userService.update(userDTO);            userVerificationResponse.setMessage("accountVerified");            userVerificationResponse.setStatus(200);            userVerificationResponse.setEmail(userDTO.getEmail());            userVerificationResponse.setId(userDTO.getId());            final String uri = "http://localhost:4200/successfulRegistration";            this.openBrowsePage(uri);        } else {            final String uri = "http://localhost:4200/invalidConfirmRegistration";            this.openBrowsePage(uri);        }    }    private void openBrowsePage(String uri) {        if (Desktop.isDesktopSupported()) {            Desktop desktop = Desktop.getDesktop();            try {                desktop.browse(new URI(uri));            } catch (IOException | URISyntaxException e) {                e.printStackTrace();            }        } else {            Runtime runtime = Runtime.getRuntime();            try {                runtime.exec("rundll32 url.dll,FileProtocolHandler " + uri);            } catch (IOException e) {                e.printStackTrace();            }        }    }    @GetMapping("/checkUserExistByEmail")    public boolean checkUserExistByEmail(@RequestParam String email) {        UserDTO userDTO = userService.findUserByEmail(email);        return userDTO != null;    }//    @GetMapping("/checkUserExistByLogin")//    public boolean checkUserExistByLogin(@RequestParam String login) {//        UserDTO userDTO = userService.findUserByLogin(login);//        return userDTO != null;//    }////    @PostMapping("/signIn")//    public UserDTO signIn(@RequestBody LoginDataDTO loginDataDTO) {//        UserVerificationResponse userVerificationResponse = new UserVerificationResponse();//        UserDTO existingUserLogin = userService.findUserByLogin(loginDataDTO.getLogin());//        if (existingUserLogin == null) {//            return null;//        } else {//            if (!existingUserLogin.getPassword().equals(loginDataDTO.getPassword())) {//                return null;//            } else {//                return existingUserLogin;//            }//        }//    }//    @GetMapping("/getUserByLogin")//    public UserDTO getUserByLogin(@RequestParam String login){//        return userService.findUserByLogin(login);//    }}